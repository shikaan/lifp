Memory management without arenas
---

- [x] Handle scalars
- [x] Handle lists
- [x] Run builtins
- [x] Run specials
  - [x] Make environments unaware of arenas
  - [x] Make Hashmaps unaware of arenas
- [x] Run functions
  - [x] Allow closures

- [ ] Support TCO with trampolines
- [ ] Memory leaks
- [ ] Rest of std


BUGS
---
  * [ ] `listGet` allows you to go out of bound

FEATURES
---
  * [ ] Load a file in REPL and continue execution from there (debug mode)
  * [ ] imports `(import! my-module "./my-module.lifp")`
  * [ ] Decouple validation from execution
  * [ ] Enforce naming conventions for functions
    * [ ] effectful functions should terminate with !
    * [ ] functions ending in ? should return bool
  * [ ] Type Declaration comments `;; (number, number) -> number`
  * [ ] Compile AST to bytecode

REFACTORING
---
  * [ ] Make list methods (and hashmap methods) typesafe (now you can append
       `node_t` to a `value_list_t` without errors)
  * [ ] Use [`libuv`](https://libuv.org) for non-blocking io

OPEN STUFF
---
* Should std and core (e.g., keywords) be split to allow using lifp without std?

; vim:ft=markdown tw=80 cc=+1

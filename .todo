BUGS
---
  * [ ] `listGet` allows you to go out of bound

FEATURES
---
  * [ ] Compile AST to bytecode
  * [ ] Implement list methods (list.map, list.each, list.times, list.filter)
  * [ ] Decouple validation from execution
  * [ ] Enforce naming conventions for functions
    * [ ] effectful functions should terminate with !
    * [ ] functions ending in ? should return bool
  * [ ] Resizable arena, to allow resizable environments
  * [ ] Tail call optimization
  * [ ] Auto-generated documentation for standard library
  * [ ] Enum to text for error messages
  * [ ] Currying: `(def! make-adder (fn (x) (fn (y) (+ x y))))\n(make-adder 5)` 
        currently loses context on `x` because of immediate invocation
  * [ ] Implement `?` in REPL
  * [ ] imports `(import! my-module "./my-module.lifp")
  * [ ] Type Declaration comments `;; (number, number) -> number`
  * [ ] Max Call Stack size
  * [ ] Run should skip comments and allow top-level atoms

REFACTORING
---
  * [ ] Make list methods (and hashmap methods) typesafe (now you can append
       `node_t` to a `value_list_t` without errors)
  * [ ] Use [`libuv`](https://libuv.org) for non-blocking io
  * [ ] Some structs are huge: mostly because we try to colocate most things. Do we need all of that?
        - The only place where we need flexible lists is the tokenizer and parser.
          From that point on all the lists have defined length and should be arrays.
        - Having colocation though helps with copying, listAppend and mapSet, since we don't have
          to follow pointers.

OPEN STUFF
---
* Should std and core (e.g., keywords) be split to allow using lifp without std?
